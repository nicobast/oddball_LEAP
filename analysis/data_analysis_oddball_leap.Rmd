---
title: "data_analysis_oddball_leap_280423"
output: html_document
date: "`r Sys.Date()`"
---

# setup

```{r setup, include=FALSE}

#chunk options
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) #warning to false

## REQUIRED PACKAGES

#analysis
require(lme4) #linear mixed models
require(lmerTest) #p-value for fixed effects in LMM
require(emmeans) #estimated marginalized means
require(performance) #r²_nakagawa - marginalized and conditionalk R² 

#packages for MMN
require(pbapply) #progress bar apply
require(zoo) #rolling mean
require(data.table) #rbindlist

#visualization
require(kableExtra) #APA tables
library(greta) #Bayesian modelling
require(bayesplot) #plotting Bayesian
require(DiagrammeR) #plotting Bayesian
require(ggplot2) #plot posterior sampling estimates

require(R.matlab) # read matlab files
require(effectsize) # cohens D

require(RColorBrewer) #color palettes
require(gridExtra) #arrange plots
require(wesanderson) #custom color palettes

require(eegkit) #standard coordinates of EEG channels - data(eegcoord)
require(eegUtils)

#INFO: eegUtils is not on CRAN and thus loaded with remote packages from github
# install.packages("remotes")
# remotes::install_github("craddm/eegUtils")



#paths
project_path<-"C:/Users/nico/PowerFolders/project_oddball_LEAP"
localation_of_EEG_allchannel_data<-"C:/Users/nico/Desktop/leap_oddball_eeg_list_allchannels.rdata"

##define parameters of posterior sampling in Bayesian modeling
number_of_warmups <- 1000
number_of_iterations <- 2000

##define percentage of data sampling for visualization
fraction_to_sample<-1 ###relevant for scalp topography
sampling_factor<-1/fraction_to_sample ### releavnt for MMN, pupil size change figures

###graphic settings

  #graphic parameters
  theme_set(theme_bw())
  
  #define color palette
  custom_condition_colors <- wes_palette('FantasticFox1',5,type='discrete')[2:5]
  custom_contrast_colors <- c(brewer.pal(6, "Blues")[4:6],brewer.pal(6, "Oranges")[4:6])
 
  #RColorBrewer::display.brewer.all()

```

# load data

Eye tracking and EEG data in separate file that are already preprocessed, see

<li> [Eye-Tracking preprocessing]: https://github.com/nicobast/oddball_LEAP/blob/master/code/data_preprocessing_oddball_leap.R </li>
<li> [EEG preprocessing]: https://github.com/nicobast/oddball_LEAP/blob/master/code/read_eeg_data.R </li>


```{r load_data_ET_EEG}

## pupil data
load(file=paste0(project_path,'/data/mmn_leap_pd_final_dfs_21022023'))

## EEG data - reduced to FZ channel - see read_eeg_data.R
#load(paste0(project_path,"/data/leap_oddball_eeg_list.rdata"))
list_eeg_redux<-readRDS(paste0(project_path,"/data/leap_oddball_eeg_list_redux.rds"))


```

Also load and merge the data generated by the PCDM computational model, see

<li> [PCDM preprocessing]: https://github.com/nicobast/oddball_LEAP/blob/master/code/PCDM_data_conversion_matlab.R </li>
<li> [PCDM computation]: https://github.com/nicobast/PCDM </li>

```{r load_data_PCDM}

#read data estimated in MAtlab
mat_output<-readMat(paste0(project_path,"/data/pcdm_estimates_1run_290323.mat"))

#extract parameters
pcdm_parameters<-mat_output[[2]]
names(pcdm_parameters)<-c('interpolateBlinks','downsampleRate','fitTimeseries','change_cutoff_by_samplingRate','low_bandpass_filter_range','blinkint_vel_thres_on','blinkint_window_from_onset','blinkint_min_dur','rel_vel_thres','min_sac_dur')

#create empty list
list_pcdm_estimates<-list()

### extract required info from matlab object in for loop
for (i in seq(length(mat_output[[1]]))){

pcdm_estimate<-mat_output[[1]][i][[1]][[1]] #extract relevant data of single participant
names(pcdm_estimate)<-dimnames(pcdm_estimate)[[1]] #assign names of dimensions
pcdm_estimate<-lapply(pcdm_estimate,unlist) # remove internal list structure

list_pcdm_estimates[[i]]<-pcdm_estimate

}

#add names
names(list_pcdm_estimates)<-sapply(list_pcdm_estimates,function(x){x['name']})

#create vectors
gain_pcdm<-unlist(sapply(list_pcdm_estimates,function(x){x['gain']}))
Rsq_pcdm<-unlist(sapply(list_pcdm_estimates,function(x){x['Rsq']}))
offset_pcdm<-unlist(sapply(list_pcdm_estimates,function(x){x['offset']}))
id<-substr(names(list_pcdm_estimates),1,nchar(names(list_pcdm_estimates))-4)
id<-id[id!=""] #remove empty entries

#exclude outliers
gain_pcdm[gain_pcdm>0.2 | gain_pcdm<(-0.2)]<-NA

#merge data
df_pcdm<-data.frame(id,gain_pcdm,Rsq_pcdm,offset_pcdm)
df_timepoint<-merge(df_timepoint,df_pcdm,by='id',all.x=T)


```

# calculate mismatch negativity (MMN)

```{r calculate mismatch negativity}

###---> calculate MMN ####

fun_estimate_mmn<-function(one_set){

  #testing
  #one_set<-list_eeg[[100]]

  ###restrict to timeframe - 35-350ms
  one_set<-one_set[one_set$times>50 & one_set$times<350,]

  mmn_trial<-with(one_set,by(Fz,trial_counter,function(channel_data){

      channel_data_smooth<-rollmean(channel_data,k=20) #rolling mean of 20ms
      min(channel_data_smooth)

  }))

  trial_counter<-names(mmn_trial)
  mmn<-as.numeric(mmn_trial)
  mmn_per_trial<-data.frame(trial_counter,mmn)
  return(mmn_per_trial)

}

list_mmn<-pblapply(list_eeg_redux,fun_estimate_mmn)

##--> create data frame
ID<-substr(names(list_mmn),10,22)
condition<-substr(names(list_mmn),1,8)

list_mmn<-pbmapply(function(x,y,z){
  x$condition<-y
  x$ID<-z
  return(x)
  },x=list_mmn,y=condition,z=ID,SIMPLIFY = F)

df_mmn<-data.table::rbindlist(list_mmn)

df_mmn$trial_counter<-as.numeric(df_mmn$trial_counter)
df_mmn$condition<-as.factor(df_mmn$condition)

```

# merge eye-tracking and EEG data

```{r merge ET and EEG}

##prepare EEG data
df_mmn$ID<-sub('/','',df_mmn$ID)
df_mmn$ID<-sub('_','',df_mmn$ID)

    #with(df_timepoint,table(subjects,wave))

    #eye-tracking data with MMN data
    table(df_timepoint$subjects %in% df_mmn$ID)
    table(unique(df_mmn$ID) %in% df_timepoint$subjects)

#create merge variables    
df_mmn$merge_id<-interaction(df_mmn$ID,df_mmn$trial_counter)
df_trial$merge_id<-interaction(df_trial$subjects,df_trial$EventCounter)

#merge - per-trial level (df_trial)
df_trial<-merge(df_trial,df_mmn,by='merge_id',all.x=T)

    table(is.na(df_mmn$mmn))
    table(is.na(df_trial$rpd_auc))
    table(is.na(df_trial$mmn)) #missing in MMN --> to be expected
    ##--> not all trials analyzed in eye-tracking were selected for EEG
    
##some trials are not correctly matched - correct for that
with(df_trial,table(condition,EventData))
df_trial_mmn<-df_trial[(df_trial$EventData=='201' & df_trial$condition=='standard'|
                 df_trial$EventData=='203' & df_trial$condition=='duration'|
                 df_trial$EventData=='202' & df_trial$condition=='frequenc'|
                 df_trial$EventData=='204' & df_trial$condition=='combined'),]

###merge per-participant level (df_timepoint)
df_mmn_timepoint<-aggregate(mmn~id+EventData,data=df_trial_mmn,FUN=mean,na.rm=T)
df_mmn_timepoint<-reshape(df_mmn_timepoint, idvar = "id", timevar = "EventData", direction = "wide")

df_timepoint<-merge(df_timepoint,df_mmn_timepoint,by='id',all.x = T)
rm(df_mmn_timepoint)

###which participants have MMN data
table(is.na(df_timepoint$mmn.201),df_timepoint$t1_diagnosis) ##

```

# descriptives table

generates a table on characteristics of the sample between groups

```{r samples description}

#### sample descriptives - PARTICIPANT specific ####

fun_return_descriptive<-function(variable,group,rounding=2,scaling=1){
  mean_values<-by(variable,group,function(x){round(mean(x,na.rm=T),rounding)})
  sd_values<-by(variable,group,function(x){round(sd(x,na.rm=T),rounding)})
  min_values<-by(variable,group,function(x){round(min(x,na.rm=T),rounding)})
  max_values<-by(variable,group,function(x){round(max(x,na.rm=T),rounding)})
  mean_values<-mean_values*scaling
  sd_values<-sd_values*scaling
  min_values<-min_values*scaling
  max_values<-max_values*scaling
  paste0(mean_values,'/',sd_values,' ','[',min_values,'-',max_values,']')
}

#standard descriptives
n_group<-with(df_dem,by(subjects,t1_diagnosis,function(x){length(unique(x))}))
gender<-with(df_dem,by(t1_sex,t1_diagnosis,function(x){paste0(table(x)[2],'/',table(x)[1])}))
timepoints<-with(df_dem,by(timepoints,t1_diagnosis,function(x){paste0(table(x)[1],'/',table(x)[2],'/',table(x)[3])}))
age<-with(df_dem,fun_return_descriptive(variable=t1_ageyrs,group=t1_diagnosis))
iq<-with(df_dem,fun_return_descriptive(variable=t1_fsiq,group=t1_diagnosis))
piq<-with(df_dem,fun_return_descriptive(variable=t1_piq,group=t1_diagnosis))
viq<-with(df_dem,fun_return_descriptive(variable=t1_viq,group=t1_diagnosis))

#clinical variables
srs<-with(df_dem,fun_return_descriptive(variable=t1_srs_rawscore,group=t1_diagnosis))
rbs_total<-with(df_dem,fun_return_descriptive(variable=t1_rbs_total,group=t1_diagnosis))
sdq_total<-with(df_dem,fun_return_descriptive(variable=t1_sdq_total_difficulties_p,group=t1_diagnosis))
adhd_inatt<-with(df_dem,fun_return_descriptive(variable=adhd_inatt,group=t1_diagnosis))
adhd_hyper<-with(df_dem,fun_return_descriptive(variable=adhd_hyper,group=t1_diagnosis))
anx_beck<-with(df_dem,fun_return_descriptive(variable=anx_beck,group=t1_diagnosis))
dep_beck<-with(df_dem,fun_return_descriptive(variable=dep_beck,group=t1_diagnosis))

##data quality
#precision<-with(df_dem,fun_return_descriptive(variable=Precision,group=t1_diagnosis))
#accuracy<-with(df_dem,fun_return_descriptive(variable=Accuracy,group=t1_diagnosis))
#sampling_rate<-with(df_dem,by(sampling_rate,t1_diagnosis,function(x){paste0(table(x)[2],'/',table(x)[1])}))
missing_data_trial<-with(df_dem,fun_return_descriptive(variable=missing_data_trial,group=t1_diagnosis,rounding=4,scaling = 100))
sampling_rate<-with(df_timepoint,by(sampling_rate,t1_diagnosis,function(x){paste0(table(x)[2],'/',table(x)[1])}))

#et vars
center_dev_id<-with(df_dem,fun_return_descriptive(variable=center_dev,group=t1_diagnosis,rounding=4,scaling=100))
screen_dist_id<-with(df_dem,fun_return_descriptive(variable=screen_dist,group=t1_diagnosis))
pd_baseline_id<-with(df_dem,fun_return_descriptive(variable=pd_baseline,group=t1_diagnosis))
# rpd_response201_id<-with(df_dem,fun_return_descriptive(variable=rpd_response.201,group=t1_diagnosis,rounding=4,scaling=100))
# rpd_response202_id<-with(df_dem,fun_return_descriptive(variable=rpd_response.202,group=t1_diagnosis,rounding=4,scaling=100))
# rpd_response203_id<-with(df_dem,fun_return_descriptive(variable=rpd_response.203,group=t1_diagnosis,rounding=4,scaling=100))
# rpd_response204_id<-with(df_dem,fun_return_descriptive(variable=rpd_response.204,group=t1_diagnosis,rounding=4,scaling=100))
# rpd_auc201_id<-with(df_dem,fun_return_descriptive(variable=rpd_auc.201,group=t1_diagnosis,rounding=4,scaling=100))
# rpd_auc202_id<-with(df_dem,fun_return_descriptive(variable=rpd_auc.202,group=t1_diagnosis,rounding=4,scaling=100))
# rpd_auc203_id<-with(df_dem,fun_return_descriptive(variable=rpd_auc.203,group=t1_diagnosis,rounding=4,scaling=100))
# rpd_auc204_id<-with(df_dem,fun_return_descriptive(variable=rpd_auc.204,group=t1_diagnosis,rounding=4,scaling=100))


rpd_auc_id<-with(df_dem,fun_return_descriptive(variable=rpd_auc,group=t1_diagnosis,rounding=4,scaling=100))


descriptives_table<-rbind(n_group,gender,timepoints,age,iq,piq,viq,
                          missing_data_trial,sampling_rate,
                          center_dev_id,screen_dist_id,pd_baseline_id,
                          srs,rbs_total,sdq_total,adhd_inatt,adhd_hyper,anx_beck,dep_beck
                          #rpd_response201_id,rpd_response202_id,rpd_response203_id,rpd_response204_id,
                          #rpd_auc201_id,rpd_auc202_id,rpd_auc203_id,rpd_auc204_id
                          )

##group differences
groupdiff_p<-c(NA,
               round(as.numeric(with(df_dem,chisq.test(t1_sex,t1_diagnosis))['p.value']),3),
               round(as.numeric(with(df_dem,chisq.test(timepoints,t1_diagnosis))['p.value']),3),
               round(as.numeric(with(df_dem,t.test(t1_ageyrs~t1_diagnosis))['p.value']),3),
               round(as.numeric(with(df_dem,t.test(t1_fsiq~t1_diagnosis))['p.value']),3),
               round(as.numeric(with(df_dem,t.test(t1_piq~t1_diagnosis))['p.value']),3),
               round(as.numeric(with(df_dem,t.test(t1_viq~t1_diagnosis))['p.value']),3),
               round(as.numeric(with(df_dem,t.test(missing_data_trial~t1_diagnosis))['p.value']),3),
               round(as.numeric(with(df_timepoint,chisq.test(sampling_rate,t1_diagnosis))['p.value']),3),
               round(as.numeric(with(df_dem,t.test(center_dev~t1_diagnosis))['p.value']),3),
               round(as.numeric(with(df_dem,t.test(screen_dist~t1_diagnosis))['p.value']),3),
               round(as.numeric(with(df_dem,t.test(pd_baseline~t1_diagnosis))['p.value']),3),
               round(as.numeric(with(df_dem,t.test(t1_srs_rawscore~t1_diagnosis))['p.value']),3),
               round(as.numeric(with(df_dem,t.test(t1_rbs_total~t1_diagnosis))['p.value']),3),
               round(as.numeric(with(df_dem,t.test(t1_sdq_total_difficulties_p~t1_diagnosis))['p.value']),3),
               round(as.numeric(with(df_dem,t.test(adhd_inatt~t1_diagnosis))['p.value']),3),
               round(as.numeric(with(df_dem,t.test(adhd_hyper~t1_diagnosis))['p.value']),3),
               round(as.numeric(with(df_dem,t.test(anx_beck~t1_diagnosis))['p.value']),3),
               round(as.numeric(with(df_dem,t.test(dep_beck~t1_diagnosis))['p.value']),3)
               # round(as.numeric(with(df_dem,t.test(rpd_response.201~t1_diagnosis))['p.value']),3),
               # round(as.numeric(with(df_dem,t.test(rpd_response.202~t1_diagnosis))['p.value']),3),
               # round(as.numeric(with(df_dem,t.test(rpd_response.203~t1_diagnosis))['p.value']),3),
               # round(as.numeric(with(df_dem,t.test(rpd_response.204~t1_diagnosis))['p.value']),3),
               # round(as.numeric(with(df_dem,t.test(rpd_auc.201~t1_diagnosis))['p.value']),3),
               # round(as.numeric(with(df_dem,t.test(rpd_auc.202~t1_diagnosis))['p.value']),3),
               # round(as.numeric(with(df_dem,t.test(rpd_auc.203~t1_diagnosis))['p.value']),3),
               # round(as.numeric(with(df_dem,t.test(rpd_auc.204~t1_diagnosis))['p.value']),3)
               )

groupdiff_p[which(groupdiff_p==0)]<-'<0.001'
groupdiff_p[which(is.na(groupdiff_p))]<-'-'

row_names<-c('n','gender (F/M)','timepoints (1/2/1+2)','age (in years)','IQ','perceptual IQ','verbal IQ',
             #'data quality: precision','data quality: accuracy',
             #'sampling rate (120Hz/300Hz)',
             'missing data per trial (%)','sampling rate (300Hz / 120Hz)',
             'gaze center deviation (%)','screen distance (mm)','mean pupil size (mm)',
             'SRS (total)','RBS (total)','SDQ (total)','ADHD inattention','ADHD hyperactivity','BAI (anxiety)','BDI (depression)'
             # 'pupillary response: amplitude - standard (%)','pupillary response: amplitude - oddball pitch (%)','pupillary response: amplitude - oddball length (%)','pupillary response: amplitude - oddball both (%)',
             # 'pupillary response: AUC - standard (%)','pupillary response: AUC - oddball pitch (%)','pupillary response: AUC - oddball length (%)','pupillary response: AUC - oddball both (%)'
             )

descriptives_table<-cbind(row_names,descriptives_table,groupdiff_p)

#add group differences
#descriptives_table<-ifelse(descriptives_table=='0','<0.001',descriptives_table)

table_sample<-descriptives_table %>%
  kbl(caption = "Sample description",
      col.names = c('','autistic individuals (ASD)','neurotypical individuals (NTC)','group difference (p)'),
      row.names = F) %>%
  kable_classic(full_width = F, html_font = "Cambria")


descriptives_table

table_sample

save_kable(table_sample, file=paste0(project_path,'/output/table_sampledescription.html'))




```

# associations of dependent variables (per participant)

correlation coefficients on per-participant level of

<li> pupillary measure: baseline pupil size (BPS) </li>
<li> pupillary measure: stimulus-evoked pupilalry response (SEPR) </li>
<li> EEG measure: mismatch negativity (MMN) </li>
<li> computational model: neural gain (NG) </li>

Event Data coding

<li> 201 = standard </li>
<li> 202 = pitch </li>
<li> 203 = length </li>
<li> 204 = pitch & length </li>


```{r associations of dependent variables}

rm(gain_pcdm)
attach(df_timepoint)

cor_table<-data.frame(t(cbind(

#SEPR -PD
cbind(cor.test(rpd_auc.201,pd)[c('data.name','estimate','p.value')]),
cbind(cor.test(rpd_auc.202,pd)[c('data.name','estimate','p.value')]),
cbind(cor.test(rpd_auc.203,pd)[c('data.name','estimate','p.value')]),
cbind(cor.test(rpd_auc.204,pd)[c('data.name','estimate','p.value')]),

#SEPR - MMN --> uncorrelated
cbind(cor.test(rpd_auc.201,mmn.201)[c('data.name','estimate','p.value')]),
cbind(cor.test(rpd_auc.202,mmn.202)[c('data.name','estimate','p.value')]),
cbind(cor.test(rpd_auc.203,mmn.203)[c('data.name','estimate','p.value')]),
cbind(cor.test(rpd_auc.204,mmn.204)[c('data.name','estimate','p.value')]),

#BPS - MMN --> substantial negative correlations
cbind(cor.test(pd,mmn.201)[c('data.name','estimate','p.value')]),
cbind(cor.test(pd,mmn.202)[c('data.name','estimate','p.value')]),
cbind(cor.test(pd,mmn.203)[c('data.name','estimate','p.value')]),
cbind(cor.test(pd,mmn.204)[c('data.name','estimate','p.value')]),

# NG - BPS
cbind(cor.test(gain_pcdm,pd)[c('data.name','estimate','p.value')]),
cbind(cor.test(gain_pcdm,pd)[c('data.name','estimate','p.value')]),
cbind(cor.test(gain_pcdm,pd)[c('data.name','estimate','p.value')]),
cbind(cor.test(gain_pcdm,pd)[c('data.name','estimate','p.value')]),

#NG - SEPR
cbind(cor.test(gain_pcdm,rpd_auc.201)[c('data.name','estimate','p.value')]),
cbind(cor.test(gain_pcdm,rpd_auc.202)[c('data.name','estimate','p.value')]),
cbind(cor.test(gain_pcdm,rpd_auc.203)[c('data.name','estimate','p.value')]),
cbind(cor.test(gain_pcdm,rpd_auc.204)[c('data.name','estimate','p.value')]),

#NG - MMN
cbind(cor.test(gain_pcdm,mmn.201)[c('data.name','estimate','p.value')]),
cbind(cor.test(gain_pcdm,mmn.202)[c('data.name','estimate','p.value')]),
cbind(cor.test(gain_pcdm,mmn.203)[c('data.name','estimate','p.value')]),
cbind(cor.test(gain_pcdm,mmn.204)[c('data.name','estimate','p.value')])


)))


#format table
cor_table$data.name<-unlist(cor_table$data.name)
cor_table$estimate<-unlist(cor_table$estimate)
cor_table$p.value<-unlist(cor_table$p.value)

cor_table$estimate<-round(cor_table$estimate,4)
cor_table$p.value<-round(cor_table$p.value,4)

cor_table$data.name<-gsub('rpd_auc','SEPR',cor_table$data.name)
cor_table$data.name<-gsub('pd','BPS',cor_table$data.name)
cor_table$data.name<-gsub('gain_pcdm','NG',cor_table$data.name)
cor_table$data.name<-gsub('MMN','MMN',cor_table$data.name)

#Bonferroni correction
number_of_comparisons<-nrow(cor_table)
cor_table$p_adjust<-cor_table$p.value*number_of_comparisons
cor_table$p_adjust<-ifelse(cor_table$p_adjust>1,1,cor_table$p_adjust)

#produce table
cor_table_format<-cor_table %>%
    kbl(caption = "correlations of BPS, SEPR, MMN, NG") %>%
    kable_classic(full_width = F, html_font = "Cambria")

cor_table_format

save(cor_table_format,file=paste0(project_path,'/output/supplements/associations_DV_perparticipant.html'))
  
```


# association of dependent variables (per trial)

```{r BPS_SEPR_association}

#interrelation of BPS and SEPR
lmm<-lmer(scale(rpd_auc)~scale(pd_baseline)+
            (1|subjects)+(1|wave),data=df_trial)
anova(lmm)

cbind(round(fixef(lmm)['scale(pd_baseline)'],2),
              round(confint(lmm,parm = 'scale(pd_baseline)'),2))

#model fit
r2_nakagawa(lmm)  
  
#BIC Bayes Factor
lmm_ML<-lmer(scale(rpd_auc)~scale(pd_baseline)+
              (1|subjects)+(1|wave),data=df_trial,REML=F)

null_lmm_ML <- lmer(scale(rpd_auc)~1+
                   (1|subjects)+(1|wave),data=df_trial,REML=F)

BF_BIC <- exp((BIC(null_lmm_ML) - BIC(lmm_ML))/2)  
BF_BIC  

```  

```{r BPS_SEPR_association_Bayesian}

 # data - create greta arrays
    x <- as_data(scale(df_trial$pd_baseline))
    y <- as_data(scale(df_trial$rpd_auc))
    subject_id <- as.integer(factor(df_trial$subjects)) #random intercept (in LMM)

    
    # variables and priors
    int <- normal(0, 1)
    coef <- normal(0, 1)
    sd <- student(3, 0, 1, truncation = c(0, Inf))
    a_subject <- normal(0, 1, dim = max(subject_id))

    # operations
    mean <- int + coef * x + a_subject[subject_id]

    # likelihood - distribution over data
    distribution(y) <- normal(mean, sd)

    # defining the model
    m <- model(int, coef, sd)

    # plotting
    #require(DiagrammeR)
    plot(m)

    # sampling
    draws <- mcmc(m, n_samples = number_of_iterations, warmup = number_of_warmups)
    summary(draws)
    
    mcmc_trace(draws) #see whether chains converge and are stationary
    mcmc_dens(draws) # + stable estimates
    
    #posterior predictive checking
    coda::gelman.diag(draws) #Rhat <= 1.01 is cutoff for reliable estimator
    coda::effectiveSize(draws) #ESS

    #save model
    draws_SEPR_BPS<-draws
    save(draws_SEPR_BPS,file=paste0(project_path,'/data/Bayesian_model_SEPR_BPS.Rdata'))


```

```{r BPS MMN association LMM}

###here use ID as random intercept (subject + wave) as MMN is only available for one timepoint

#interrelation of BPS and SEPR
lmm<-lmer(scale(mmn)~scale(pd_baseline)*EventData+
            (1|id),data=df_trial)

anova(lmm)

cbind(round(fixef(lmm)['scale(pd_baseline)'],2),
              round(confint(lmm,parm = 'scale(pd_baseline)'),2))

#model fit
r2_nakagawa(lmm)  
  
#BIC Bayes Factor
lmm_ML<-lmer(scale(mmn)~scale(pd_baseline)+EventData+
              (1|id),data=df_trial,REML=F)

null_lmm_ML <- lmer(scale(mmn)~EventData+
                   (1|id),data=df_trial,REML=F)

BF_BIC <- exp((BIC(null_lmm_ML) - BIC(lmm_ML))/2)  
BF_BIC  



```

```{r SEPR MMN association LMM}

###here use ID as random intercept (subject + wave) as MMN is only available for one timepoint

#interrelation of BPS and SEPR
lmm<-lmer(scale(mmn)~scale(rpd_auc)*EventData+
            (1|id),data=df_trial)

anova(lmm)

cbind(round(fixef(lmm)['scale(rpd_auc)'],2),
              round(confint(lmm,parm = 'scale(rpd_auc)'),2))

#model fit
r2_nakagawa(lmm)  
  
#BIC Bayes Factor
lmm_ML<-lmer(scale(mmn)~scale(rpd_auc)+
              (1|id),data=df_trial,REML=F)

null_lmm_ML <- lmer(scale(mmn)~1+
                   (1|id),data=df_trial,REML=F)

BF_BIC <- exp((BIC(null_lmm_ML) - BIC(lmm_ML))/2)  
BF_BIC  


```

# composite figure - pupil size and Fz amplitude change within trials

visualization of pupile size change (BPS,SEPR) and Fz amplitude change (MMN) within trials

## MMN - scalp topography (part 1)

```{r scalp topography, warnings=F}

#load all EEG channel data - LARGE FILE ON DIFFERENT DRIVE
load(file=localation_of_EEG_allchannel_data)

#for standard coordinates of electrodes
data(eegcoord) #load sample set with standard coordinates
#rownames(eegcoord) #names of channels

###select only participants that are in final sample
subjects_in_list<-substr(names(list_mmn),10,22)
subjects_in_list<-sub('/','',subjects_in_list)
subjects_in_list<-sub('_','',subjects_in_list)
list_elements_in_final_sample<-which(subjects_in_list %in% unique(df_trial$subjects))
list_eeg_selected<-list_eeg[list_elements_in_final_sample]

#participants_to_sample<-round(length(list_eeg)/4*fraction_to_sample)
participants_to_sample<-round(length(list_eeg_selected)/4*fraction_to_sample)

#select 30 random from each condition - same participants
combined_sampled<-sample(1:(length(list_eeg_selected)/4),participants_to_sample)
duration_sampled<-combined_sampled+length(list_eeg_selected)/4
frequency_sampled<-combined_sampled+2*length(list_eeg_selected)/4
standard_sampled<-combined_sampled+3*length(list_eeg_selected)/4

select_samples<-c(combined_sampled,
                  duration_sampled,
                  frequency_sampled,
                  standard_sampled)

#select thirty random participants - from participants that have ET data
list_eeg_selected<-list_eeg_selected[select_samples]

fun_prepare_channeldata_plotting<-function(one_set,sample_coordinates){

  ##testing
  # one_set<-list_eeg_selected[[1]]
  # sample_coordinates<-eegcoord
  
  #match names of sample coordnisates and data set
  names(one_set)<-toupper(names(one_set)) #capitalize names - naming convention of eegkit
  sample_coordinates<-sample_coordinates[rownames(sample_coordinates) %in% names(one_set),]
  sample_coordinates$variable<-rownames(sample_coordinates)


  #limit site to interested timeframe - 150-250 ms after trial onset
  one_set<-one_set[one_set$TIMES >= 150 & one_set$TIMES <= 250,]
      ###--> less flexibel but reduces file size
  
  #melt to long format
  one_set$TIMES<-as.factor(one_set$TIMES) #preserve in melting
  one_set<-reshape2::melt(one_set,value.name='amplitude') #convert to long format

  #merge with sampel coordinates
  one_set<-merge(one_set,sample_coordinates,by='variable') #merge with sample coordniates
  names(one_set)[1]<-'electrode' #set name for later plotting function
  one_set$TIMES<-as.numeric(levels(one_set$TIMES))[one_set$TIMES]
  
  return(one_set)

      }

#takes around 20 minutes
list_eeg_selected<-pblapply(list_eeg_selected,fun_prepare_channeldata_plotting,sample_coordinates=eegcoord)
df_plot<-data.table::rbindlist(list_eeg_selected)

#scalp topography separated for condition
limits_of_plotted_range<-c(-3,3)

gf_4a<-topoplot(df_plot[df_plot$CONDITION=='standard',], 
         interp_limit='head',limits=limits_of_plotted_range)+labs(title='standard') #scale coordniates to head

gf_4b<-topoplot(df_plot[df_plot$CONDITION=='frequenc',], 
         interp_limit='head',limits=limits_of_plotted_range)+labs(title='pitch oddball') #scale coordniates to head

gf_4c<-topoplot(df_plot[df_plot$CONDITION=='duration',], 
         interp_limit='head',limits=limits_of_plotted_range)+labs(title='length oddball') #scale coordniates to head

gf_4d<-topoplot(df_plot[df_plot$CONDITION=='combined',],
         interp_limit='head',limits=limits_of_plotted_range)+labs(title='pitch & length oddball') #scale coordniates to head


#extract legend
g_legend<-function(x){
  tmp <- ggplot_gtable(ggplot_build(x))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)}

mylegend<-g_legend(gf_4a)

#plot in markdown
# grid.arrange(
#   arrangeGrob(
#     gf_4a + theme(legend.position="none"),
#     gf_4b + theme(legend.position="none"),
#     gf_4c + theme(legend.position="none"),
#     gf_4d + theme(legend.position="none"),nrow=2),
#   mylegend, ncol=2, widths=c(5,1))


```

## MMN - Fz amplitude change within trials (part 2)

```{r Fz amplitude change}

df_eeg<-data.table::rbindlist(list_eeg_redux) ##very fast compared to do.call(rbind)

subsample<-sample(1:nrow(df_eeg),nrow(df_eeg)/sampling_factor) # select 10% of data for faster plotting

    ### use participants selected for scalp topography - much slower and same results
    # df_eeg$ID<-sub('/','',df_eeg$ID)
    # df_eeg$ID<-sub('_','',df_eeg$ID)
    # selected_participants<-substr(names(list_mmn)[combined_sampled],10,21)
    # subsample<-which(df_eeg$ID %in% selected_participants)

custom_condition_colors <- rev(wes_palette('FantasticFox1',5,type='discrete')[2:5]) #reverse custom colors to match color coding in other figures

gf_1<-ggplot(df_eeg[subsample,],aes(x=times,y=Fz,group=condition,color=condition,fill=condition))+geom_smooth()+
  labs(y='electrode Fz - amplitute (uV)',x='trial duration (ms)')+
  scale_fill_manual(values = custom_condition_colors, labels=c("standard" = "standard", "frequenc" = "pitch oddball", "duration" = "length oddball ", "combined" = "pitch & length oddball"))+
  scale_color_manual(values = custom_condition_colors, labels=c("standard" = "standard", "frequenc" = "pitch oddball", "duration" = "length oddball ", "combined" = "pitch & length oddball"))

#gf_1

```


## pupil size change within trial - progression between groups (part 3+4)

```{r pupil size change signal}

#sample data
sampled_df<-df[sample(1:nrow(df),nrow(df)/sampling_factor),]
#ON FULL DATA - takes 1hour+ to complete

gf_2<-ggplot(sampled_df[sampled_df$time_event<0.6,],aes(x=time_event,y=rpd,group=EventData,color=EventData,fill=EventData))+
  geom_smooth(alpha=0.4)+
  labs(x='trial duration (s)',y='pupil size (mm)')+
  scale_fill_manual(values = custom_condition_colors, labels=c("201" = "standard", "202" = "pitch oddball", "203" = "length oddball ", "204" = "pitch & length oddball"))+
  scale_color_manual(values = custom_condition_colors, labels=c("201" = "standard", "202" = "pitch oddball", "203" = "length oddball ", "204" = "pitch & length oddball"))


#add demographics data
df_dem_merge<-df_dem[,c('subjects','t1_group','t1_diagnosis','t1_sex','t1_ageyrs','t2_ageyrs','t1_fsiq','t1_piq','t1_viq')]
df_dem_merge$subjects<-as.character(df_dem_merge$subjects)
sampled_df$subjects<-substr(sampled_df$id,1,12)
sampled_df<-merge(sampled_df,df_dem_merge,by='subjects') ###--> takes a while

    
#define quartiles
sampled_df$trial_position<-ifelse(sampled_df$EventCounter<350,'first quarter',
  ifelse(sampled_df$EventCounter>1050,'last quarter',
         ifelse(sampled_df$EventCounter>=350 & sampled_df$EventCounter<=700,'second quarter',
                ifelse(sampled_df$EventCounter>700 & sampled_df$EventCounter<=1050,'third quarter',NA
                                       ))))

sampled_df$trial_position<-factor(sampled_df$trial_position,
                                  levels=c('first quarter','second quarter','third quarter','last quarter'))

#plot split by group and quartiles
gf_3<-ggplot(sampled_df[sampled_df$time_event<0.60 & !is.na(sampled_df$trial_position),],
       aes(x=time_event,y=rpd,group=interaction(t1_diagnosis,EventData),
           color=EventData,fill=EventData,linetype=t1_diagnosis))+
  facet_grid(EventData ~ trial_position)+
  geom_smooth()+
  #geom_smooth(formula = y ~ x + poly(x,4))
  scale_linetype_discrete(labels=c("ASD" = "autistic", "Control" = "non-autistic"))+
  scale_fill_manual(values = custom_condition_colors,
                     labels=c("201" = "standard",
                              "202" = "pitch oddball",
                              "203" = "length oddball ",
                              "204" = "pitch & length oddball"))+
  scale_color_manual(values = custom_condition_colors,
                     labels=c("201" = "standard",
                              "202" = "pitch oddball",
                              "203" = "length oddball ",
                              "204" = "pitch & length oddball"))+
  labs(x='trial duration (s)',y='pupil size (mm)',color='task condition',fill='task condition',linetype='group')+
  theme(strip.text.y = element_blank()) #remove labels on facet axis


#extract legend
g_legend<-function(x){
  tmp <- ggplot_gtable(ggplot_build(x))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)}

mylegend_pupil<-g_legend(gf_3)

#print in markdown
#grid.arrange(gf_2+theme(legend.position = 'none'),gf_3,widths=c(1,1.3))    
     
```

## save composite figure

```{r save composite figure to file}

#save to file
tiff(file=paste0(project_path,"/output/figures/figure_pupil_mmn_withintrial.tiff"), # create a file in tiff format in current working directory
     width=12, height=8, units="in", res=300, compression='lzw') #define size and resolution of the resulting figure


grid.arrange(
  arrangeGrob(gf_2+theme(legend.position = 'none'),
              gf_3+theme(legend.position = 'none'),
              mylegend_pupil,ncol=3,widths=c(5,5,2)), #pupil size change Grob 
  arrangeGrob(gf_1+theme(legend.position = 'none'), #MMN Grob
              arrangeGrob(
                gf_4a + theme(legend.position="none"),
                gf_4b + theme(legend.position="none"),
                gf_4c + theme(legend.position="none"),
                gf_4d + theme(legend.position="none"),nrow=2),
              mylegend, ncol=3, widths=c(5,5,2)),
  nrow=2)

dev.off() #close operation and save file


```

# task effects

investigates influence of stimulus and task progression on pupillary measures (BPS, SEPR) and EEG measure (MMN)
in separate linear mixed models and supported by Bayesian posterior sampling

## task condition / stimulus effect

```{r stimulus_on_BPS}

##BPS
## include trial characteristics - TRIAL CONDITION
lmm<-lmer(scale(pd_baseline)~EventData+
            (1|subjects)+(1|wave),data=df_trial)

anova(lmm)
emmeans(lmm,~EventData)
confint(contrast(emmeans(lmm,~EventData),'pairwise'))
###--> 201 > 202 + 204; 203 > 202

r2_nakagawa(lmm)  
  
#BIC Bayes Factor
lmm_ML<-lmer(scale(pd_baseline)~EventData+
              (1|subjects)+(1|wave),data=df_trial,REML=F)

# null_lmm_ML <- lmer(scale(pd_baseline)~1+
#                    (1|subjects)+(1|wave),data=df_trial,REML=F)

BF_BIC <- exp((BIC(null_lmm_ML) - BIC(lmm_ML))/2)  
BF_BIC  
 
```

```{r stimulus_on_BPS_Bayesian}

    # data - create greta arrays
    y <- as_data(scale(df_trial$pd_baseline))
    events <- as_data(model.matrix(~ EventData - 1, df_trial)) #alternative to dummy coding?
    subject_id <- as.integer(factor(df_trial$subjects)) #random intercept (in LMM)

    # variables and priors
    int <- normal(0, 1)
    event_coef<- normal(0, 1, dim=ncol(events))
    sd <- student(3, 0, 1, truncation = c(0, Inf))
    a_subject <- normal(0, 1, dim = max(subject_id))

    # operations
    mean <- events %*% event_coef + a_subject[subject_id]

    # likelihood - distribution over data
    distribution(y) <- normal(mean, sd)

    # defining the model
    m <- model(event_coef)

    # sampling
    draws <- mcmc(m, n_samples = number_of_iterations, warmup = number_of_warmups)
    summary(draws)
    
    mcmc_intervals(draws, prob= .66, prob_outer = .95)
    
    mcmc_trace(draws) #see whether chains converge and are stationary
    mcmc_dens(draws) # + stable estimates

    #posterior predictive checking
    coda::gelman.diag(draws) #Rhat <= 1.01 is cutoff for reliable estimator
    coda::effectiveSize(draws) #ESS

    #save model
    draws_BPS_trialcondition<-draws
    save(draws_BPS_trialcondition,file=paste0(project_path,'/data/Bayesian_model_BPS_trialcondition.Rdata'))

```

```{r stimulus_on_SEPR}

##SEPR
  
## include trial characteristics - TRIAL CONDITION
lmm<-lmer(scale(rpd_auc)~EventData+
            (1|subjects)+(1|wave),data=df_trial)

anova(lmm)
emmeans(lmm,~EventData)
confint(contrast(emmeans(lmm,~EventData),'pairwise'))
###--> 201 > 202 + 204; 203 > 202

r2_nakagawa(lmm)  
  
#BIC Bayes Factor  
lmm_ML<-lmer(scale(rpd_auc)~EventData+
          (1|subjects)+(1|wave),data=df_trial,REML=F)

null_lmm_ML <- lmer(scale(rpd_auc)~1+
                 (1|subjects)+(1|wave),data=df_trial,REML=F)

BF_BIC <- exp((BIC(null_lmm_ML) - BIC(lmm_ML))/2)  # BICs to Bayes factor
BF_BIC
  
```

```{r stimulus_on_SEPR_Bayesian}

    # data - create greta arrays
    y <- as_data(scale(df_trial$rpd_auc))
    events <- as_data(model.matrix(~ EventData - 1, df_trial)) #alternative to dummy coding?
    subject_id <- as.integer(factor(df_trial$subjects)) #random intercept (in LMM)

    # variables and priors
    int <- normal(0, 1)
    event_coef<- normal(0, 1, dim=ncol(events))
    sd <- student(3, 0, 1, truncation = c(0, Inf))
    a_subject <- normal(0, 1, dim = max(subject_id))

    # operations
    mean <- int + events %*% event_coef + a_subject[subject_id]

    # likelihood - distribution over data
    distribution(y) <- normal(mean, sd)

    # defining the model
    m <- model(event_coef)

    # sampling
    draws <- mcmc(m, n_samples = number_of_iterations, warmup = number_of_warmups)
    summary(draws)
    
    mcmc_intervals(draws, prob= .66, prob_outer = .95)+scale_y_discrete(labels=c('standard','pitch oddball','length oddball','pitch & length oddball'))+coord_flip()+theme_bw()
    
    mcmc_trace(draws) #see whether chains converge and are stationary
    mcmc_dens(draws) # + stable estimates

    
    #posterior predictive checking
    coda::gelman.diag(draws) #Rhat <= 1.01 is cutoff for reliable estimator
    coda::effectiveSize(draws) #ESS

    #save model
    draws_SEPR_taskcondition<-draws
    save(draws_SEPR_taskcondition,file=paste0(project_path,'/data/Bayesian_model_SEPR_taskcondition.Rdata'))
        
```

```{r stimulus_on_MMN}

## include trial characteristics - TRIAL CONDITION
lmm<-lmer(scale(mmn)~EventData+
            (1|id),data=df_trial)

anova(lmm)
emmeans(lmm,~EventData)
confint(contrast(emmeans(lmm,~EventData),'pairwise'))

r2_nakagawa(lmm)  
  
#BIC Bayes Factor  
lmm_ML<-lmer(scale(mmn)~EventData+
          (1|id),data=df_trial,REML=F)

null_lmm_ML <- lmer(scale(mmn)~1+
                 (1|id),data=df_trial,REML=F)

BF_BIC <- exp((BIC(null_lmm_ML) - BIC(lmm_ML))/2)  # BICs to Bayes factor
BF_BIC
  
```

## task progression effect

```{r task_progression_on_BPS}
  
## include trial characteristics - TASK PROGRESSION
  lmm<-lmer(scale(pd_baseline)~EventCounter+
              (1|subjects)+(1|wave),data=df_trial)
  
  anova(lmm)
  
  cbind(round(fixef(lmm)['EventCounter'],9),
                round(confint(lmm,parm = 'EventCounter'),9))

  
  confint(contrast(emmeans(lmm,~EventCounter,at=list(EventCounter =     seq(1,1400,1399))),'pairwise'))

r2_nakagawa(lmm)  
 

#BIC Bayes Factor
lmm_ML<-lmer(scale(pd_baseline)~EventCounter+
              (1|subjects)+(1|wave),data=df_trial,REML=F)

null_lmm_ML <- lmer(scale(pd_baseline)~1+
                   (1|subjects)+(1|wave),data=df_trial,REML=F)

BF_BIC <- exp((BIC(null_lmm_ML) - BIC(lmm_ML))/2)  
BF_BIC  



```

```{r task progression on BPS - Bayesian}

 # data - create greta arrays
    y <- as_data(scale(df_trial$pd_baseline))
    trials <- as_data(scale(df_trial$EventCounter))
    subject_id <- as.integer(factor(df_trial$subjects)) #random intercept (in LMM)

    
    # variables and priors
    int <- normal(0, 1)
    coef <- normal(0, 1)
    sd <- student(3, 0, 1, truncation = c(0, Inf))
    a_subject <- normal(0, 1, dim = max(subject_id))

    # operations
    mean <- int + coef * trials + a_subject[subject_id]

    # likelihood - distribution over data
    distribution(y) <- normal(mean, sd)

    # defining the model
    m <- model(int, coef, sd)

    # sampling
    draws <- mcmc(m, n_samples = number_of_iterations, warmup = number_of_warmups)
    summary(draws)
    
    #diangostics
    mcmc_trace(draws) #see whether chains converge and are stationary
    mcmc_dens(draws) # + stable estimates

    #posterior predictive checking
    coda::gelman.diag(draws) #Rhat <= 1.01 is cutoff for reliable estimator
    coda::effectiveSize(draws) #ESS

    #save model
    draws_BPS_taskprogression<-draws
    save(draws_BPS_taskprogression,file=paste0(project_path,'/data/Bayesian_model_BPS_taskprogression.Rdata'))


```

```{r task progression on SEPR}

## include trial characteristics - TASK PROGRESSION
  lmm<-lmer(scale(rpd_auc)~EventCounter+
              (1|subjects)+(1|wave),data=df_trial)
  anova(lmm)
  
  cbind(round(fixef(lmm)['EventCounter'],9),
                round(confint(lmm,parm = 'EventCounter'),9))

  confint(contrast(emmeans(lmm,~EventCounter,at=list(EventCounter =   seq(1,1400,1399))),'pairwise'))
  
r2_nakagawa(lmm)  
  
#BIC Bayes Factor
lmm_ML<-lmer(scale(rpd_auc)~EventCounter+
              (1|subjects)+(1|wave),data=df_trial,REML=F)

null_lmm_ML <- lmer(scale(rpd_auc)~1+
                   (1|subjects)+(1|wave),data=df_trial,REML=F)

BF_BIC <- exp((BIC(null_lmm_ML) - BIC(lmm_ML))/2)  
BF_BIC  


```

```{r task progression on SEPR - Bayesian}

 # data - create greta arrays
    y <- as_data(scale(df_trial$rpd_auc))
    trials <- as_data(scale(df_trial$EventCounter))
    subject_id <- as.integer(factor(df_trial$subjects)) #random intercept (in LMM)

    
    # variables and priors
    int <- normal(0, 1)
    coef <- normal(0, 1)
    sd <- student(3, 0, 1, truncation = c(0, Inf))
    a_subject <- normal(0, 1, dim = max(subject_id))

    # operations
    mean <- coef * trials + a_subject[subject_id]

    # likelihood - distribution over data
    distribution(y) <- normal(mean, sd)

    # defining the model
    m <- model(coef)

    # sampling
    draws <- mcmc(m, n_samples = number_of_iterations, warmup = number_of_warmups)
    summary(draws)
    
    mcmc_trace(draws) #see whether chains converge and are stationary
    mcmc_dens(draws) # + stable estimates

    #posterior predictive checking
    coda::gelman.diag(draws) #Rhat <= 1.01 is cutoff for reliable estimator
    coda::effectiveSize(draws) #ESS

    #save model
    draws_SEPR_taskprogression<-draws
    save(draws_SEPR_taskprogression,file=paste0(project_path,'/data/Bayesian_model_SEPR_taskprogression.Rdata'))
    
```

```{r task progression on MMN}

## include trial characteristics - TASK PROGRESSION
  lmm<-lmer(scale(mmn)~EventCounter+
              (1|id),data=df_trial)
  anova(lmm)
  
  cbind(round(fixef(lmm)['EventCounter'],9),
                round(confint(lmm,parm = 'EventCounter'),9))

  confint(contrast(emmeans(lmm,~EventCounter,at=list(EventCounter =   seq(1,1400,1399))),'pairwise'))
  
r2_nakagawa(lmm)  
  
#BIC Bayes Factor
lmm_ML<-lmer(scale(mmn)~EventCounter+
              (1|id),data=df_trial,REML=F)

null_lmm_ML <- lmer(scale(mmn)~1+
                   (1|id),data=df_trial,REML=F)

BF_BIC <- exp((BIC(null_lmm_ML) - BIC(lmm_ML))/2)  
BF_BIC  

```

create a combined figure of stimulus and task progression effects on BPS, SEPR, MMN

```{r figure_task_effects}

#y-axis limitation for combined plot
y_axis_limitation<-c(-0.1, 0.15)

#BPS
lmm<-lmer(scale(pd_baseline)~EventData+
              (1|subjects)+(1|wave),data=df_trial)

#create plot --> of contrasts
plot_task_effect<-plot(contrast(emmeans(lmm,~EventData),'pairwise'))[['data']]

#modify plot
g1<-ggplot(plot_task_effect,aes(x=contrast,y=the.emmean))+
  #conventional error bar
  geom_errorbar(aes(min=asymp.LCL,max=asymp.UCL),width=0.2)+
  
  # #overplot predicted values
  # geom_jitter(data=df_plot_predicted_bps[complete.cases(df_plot_predicted_bps),],
  #             aes(x=predicted_bps_eventdata,
  #                 y=predicted_bps_mean,color=predicted_bps_eventdata),alpha=0.3,width=0.4,show.legend=F)+
  #boxplot
  geom_boxplot(aes(fill=contrast,
                   middle=the.emmean,
                   lower=the.emmean-1.5*SE,
                   upper=the.emmean+1.5*SE,
                   ymin=asymp.LCL,
                   ymax=asymp.UCL),stat = "identity",alpha=0.7)+
  scale_fill_manual(values = custom_contrast_colors,labels = c('standard - pitch','standard - length','standard - pitch & length','pitch - length','pitch - pitch & length','length - pitch & length'))+
  scale_x_discrete(labels = NULL, breaks = NULL)+ #remove x-axis tick labels
  coord_cartesian(ylim = y_axis_limitation)+
  labs(x='contrast of stimuli',y='BPS difference (z)')
  

#SEPR -pupillary response - technical model
lmm<-lmer(scale(rpd_auc)~EventData+
              (1|subjects)+(1|wave),data=df_trial)

#create plot --> of contrasts
plot_task_effect<-plot(contrast(emmeans(lmm,~EventData),'pairwise'))[['data']]

#modify plot
g2<-ggplot(plot_task_effect,aes(x=contrast,y=the.emmean))+
  #conventional error bar
  geom_errorbar(aes(min=asymp.LCL,max=asymp.UCL),width=0.2)+
  
    #boxplot
  geom_boxplot(aes(fill=contrast,
                   middle=the.emmean,
                   lower=the.emmean-1.5*SE,
                   upper=the.emmean+1.5*SE,
                   ymin=asymp.LCL,
                   ymax=asymp.UCL),stat = "identity",alpha=0.7)+
  scale_fill_manual(values = custom_contrast_colors,labels = c('standard - pitch','standard - length','standard - pitch & length','pitch - length','pitch - pitch & length','length - pitch & length'))+
  scale_x_discrete(labels = NULL, breaks = NULL)+ #remove x-axis tick labels
  coord_cartesian(ylim = y_axis_limitation)+
  labs(x='contrast of stimuli',y='SEPR difference (z)')

##MMN
lmm<-lmer(scale(mmn)~EventData+(1|id),df_trial)

      #create plot --> of contrasts
      plot_task_effect<-plot(contrast(emmeans(lmm,~EventData),'pairwise'))[['data']]

      #modify plot
      g3<-ggplot(plot_task_effect,aes(x=contrast,y=the.emmean))+
        #conventional error bar
        geom_errorbar(aes(min=asymp.LCL,max=asymp.UCL),width=0.2)+
        geom_boxplot(aes(fill=contrast,
                         middle=the.emmean,
                         lower=the.emmean-1.5*SE,
                         upper=the.emmean+1.5*SE,
                         ymin=asymp.LCL,
                         ymax=asymp.UCL),stat = "identity",alpha=0.7)+
        scale_fill_manual(values = custom_contrast_colors,labels = c('standard - pitch','standard - length','standard - pitch & length','pitch - length','pitch - pitch & length','length - pitch & length'))+
        scale_x_discrete(labels = NULL, breaks = NULL)+ #remove x-axis tick labels
        coord_cartesian(ylim = y_axis_limitation)+
        labs(x='contrast of stimuli',y='MMN difference (z)')


###task progression BPS
BPS_progression<-lmer(scale(pd_baseline)~EventCounter+
              (1|subjects)+(1|wave),data=df_trial)
      
      
model_plot_data_BPS<-as.data.frame(emmeans(BPS_progression,~EventCounter,at=list(EventCounter = seq(1,1400,140))))
    
g4<-ggplot(model_plot_data_BPS,aes(x=EventCounter,y=emmean))+
  geom_crossbar(aes(ymin=emmean-1*SE,ymax=emmean+1*SE),alpha=0.8,position='dodge',fill='grey15')+
  geom_errorbar(aes(ymin=asymp.LCL,ymax=asymp.UCL),position='dodge')+
  coord_cartesian(ylim = c(-0.125,0.2))+
  labs(x='task progression (trial)',y='baseline pupil size (BPS, z)')

###task progression SEPR
SEPR_progression<-lmer(scale(rpd_auc)~EventCounter+
              (1|subjects)+(1|wave),data=df_trial)
      
      
model_plot_data_SEPR<-as.data.frame(emmeans(SEPR_progression,~EventCounter,at=list(EventCounter = seq(1,1400,140))))
    
g5<-ggplot(model_plot_data_SEPR,aes(x=EventCounter,y=emmean))+
  geom_crossbar(aes(ymin=emmean-1*SE,ymax=emmean+1*SE),alpha=0.8,position='dodge',fill='grey15')+
  geom_errorbar(aes(ymin=asymp.LCL,ymax=asymp.UCL),position='dodge')+
  coord_cartesian(ylim = c(-0.125,0.2))+
  labs(x='task progression (trial)',y='pupillary response (SEPR, z)')

###task progression MMN
MMN_progression<-lmer(scale(mmn)~EventCounter+
              (1|id),data=df_trial)
      
model_plot_data_MMN<-as.data.frame(emmeans(MMN_progression,~EventCounter,at=list(EventCounter = seq(1,1400,140))))
    
g6<-ggplot(model_plot_data_MMN,aes(x=EventCounter,y=emmean))+
  geom_crossbar(aes(ymin=emmean-1*SE,ymax=emmean+1*SE),alpha=0.8,position='dodge',fill='grey15')+
  geom_errorbar(aes(ymin=asymp.LCL,ymax=asymp.UCL),position='dodge')+
  coord_cartesian(ylim = c(-0.125,0.2))+
  labs(x='task progression (trial)',y='mismatch negativity (MMN, z)')

#extract legend
g_legend<-function(x){
  tmp <- ggplot_gtable(ggplot_build(x))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)}

mylegend_contrast<-g_legend(g3)

      
###composite figure layout
lay <- rbind(c(1,2,3,7),
             c(4,5,6,7))


#plot in markdown
grid.arrange(g4+xlab(''),
             g5,
             g6+xlab(''),
             g1+theme(legend.position="none")+xlab(''),
             g2+theme(legend.position="none"),
             g3+theme(legend.position="none")+xlab(''),
             mylegend_contrast,layout_matrix=lay)

#save to file
tiff(file=paste0(project_path,"/output/figures/task_effects_contrasts_progression.tiff"), # create a file in tiff format in 
  width=8, height=5, units="in", res=300, compression='lzw') #define size and resolution of the resulting figure

grid.arrange(g4+xlab(''),
             g5,
             g6+xlab(''),
             g1+theme(legend.position="none")+xlab(''),
             g2+theme(legend.position="none"),
             g3+theme(legend.position="none")+xlab(''),
             mylegend_contrast,layout_matrix=lay)
      

dev.off() #close operation and save file


```

# group differences

## baseline pupil size (BPS)

```{r BPS task progression between groups - LMM}

#main model
lmm_REML<-lmer(scale(pd_baseline)~EventData*t1_diagnosis*EventCounter+
              (1|subjects)+(1|wave),data=df_trial)

#fixed effect significances
anova(lmm_REML)

#model fit
r2_nakagawa(lmm_REML)

#POST-HOC

#Post-hoc - between group
emtrends(lmm_REML,~t1_diagnosis,var='EventCounter')
#magnitude of change relative to SE
emmeans(lmm_REML,~t1_diagnosis+EventCounter,at=list(EventCounter = seq(1,1400,1399)))

  confint(contrast(emmeans(lmm_REML,~EventCounter|t1_diagnosis,at=list(EventCounter =   seq(1,1400,1399))),'revpairwise'))


#Post-hoc - between condition
emtrends(lmm_REML,~EventData,var='EventCounter')

#Bayes factor - group x task progression
lmm_ML<-lmer(scale(pd_baseline)~EventData*t1_diagnosis*EventCounter+
              (1|subjects)+(1|wave),data=df_trial,REML=F)

null_lmm_ML <- lmer(scale(pd_baseline)~EventData+t1_diagnosis+EventCounter+
                   EventData:EventCounter+EventData:t1_diagnosis+
              (1|subjects)+(1|wave),data=df_trial,REML=F)

BF_BIC <- exp((BIC(null_lmm_ML) - BIC(lmm_ML))/2)  # BICs to Bayes factor
BF_BIC

#Bayes factor - trial condition x task progression
null_lmm_ML <- lmer(scale(pd_baseline)~EventData+t1_diagnosis+EventCounter+
                   EventData:t1_diagnosis+t1_diagnosis:EventCounter+
              (1|subjects)+(1|wave),data=df_trial,REML=F)

        BF_BIC <- exp((BIC(null_lmm_ML) - BIC(lmm_ML))/2)  # BICs to Bayes factor
        BF_BIC
        
        
#full model        
lmm_full<-lmer(scale(pd_baseline)~EventData*t1_diagnosis*EventCounter+
      scale(ageyrs)+scale(t1_piq)+sex+
      as.factor(sampling_rate)+scale(center_dev)+scale(missing_data_trial)+
      (1|subjects)+(1|wave),data=df_trial)

anova(lmm_full)

#coefficient of determination
r2_nakagawa(lmm_full)


##supplements - full table
  row_names<-c('trial condition (TC)','group','task progression (TP)',
               'age','perceptual IQ','sex',
               'sampling rate','gaze center deviation','data quality',
               'TC x group','TC x TP','group x TP','TC x group x TP')
  
  
  table_data_model<-round(anova(lmm_full),3)
  table_data_model<-cbind(row_names,table_data_model)
  
  table_data_model
  
  table_model<-table_data_model %>%
    kbl(caption = "Linear mixed model: baseline pupil size (BPS)",
        col.names = c('','Sum Sq','Mean Sq','df1','df2','F','p'),
        row.names = F) %>%
    kable_classic(full_width = F, html_font = "Cambria")
  
  
  table_model
  
  save_kable(table_model, file= 'output/supplements/table_model_BPS.html')
  
```

```{r BPS task progression between groups - Bayesian}

####--> reun with more iterations

# A. translate data - make greta arrays
y <- as_data(scale(df_trial$pd_baseline))
design <- as.matrix(cbind(ifelse(df_trial$t1_diagnosis=='ASD',T,F),df_trial$EventCounter))
subject_id <- as.integer(factor(df_trial$subjects)) #random intercept (in LMM)

#define priors
int <- normal(0, 1)
design_coef<- normal(0, 1, dim=ncol(design))
sd <- cauchy(0, 3, truncation = c(0, Inf))
#sd <- student(3, 0, 1, truncation = c(0, Inf))
a_subject <- normal(0, 1, dim = max(subject_id))

#OPERATIONS - MODEL
mean <- int + design %*% design_coef + a_subject[subject_id]

# likelihood - distribution over data
distribution(y) <- normal(mean, sd)

# defining the model
m <- model(design_coef)

# sampling
start <-Sys.time()
draws <- mcmc(m, n_samples = number_of_iterations, warmup = number_of_warmups,) ###--> test
Sys.time() - start

#stability of estimates
mcmc_trace(draws) #see whether chains converge and are stationary
mcmc_dens(draws) # + stable estimates

#analyse
summary(draws)
plot(draws)

#posterior predictive checking
coda::gelman.diag(draws) #Rhat <= 1.01 is cutoff for reliable estimator
coda::effectiveSize(draws) #ESS

#save model
draws_BPS_twoway<-draws
save(draws_BPS_twoway,file=paste0(project_path,'/data/Bayesian_model_BPS_twoway.Rdata'))
    

```

```{r BPS habituation between groups - LMM}

  with(df_trial,table(sequence_position,EventData))
  ###--> weird distribution?

  #recoding
  df_trial$sequence_position_z<-scale(df_trial$sequence_position)

          #figure
        df_trial$standardtrial<-with(df_trial,ifelse(EventData==201,T,F))
        ggplot(df_trial[df_trial$sequence_position<=10,],aes(x=sequence_position,y=scale(pd_baseline),group=interaction(standardtrial,t1_diagnosis),color=standardtrial,linetype=t1_diagnosis))+
          geom_smooth()+labs(x='sequence position',y='BPS (z)')+scale_x_continuous(breaks=1:10)+theme_bw()
        ggplot(df_trial[df_trial$sequence_position<=10,],aes(x=sequence_position,y=scale(rpd_response),group=interaction(standardtrial,t1_diagnosis),color=t1_diagnosis,linetype=standardtrial))+
          geom_smooth()+labs(x='sequence position',y='SEPR (z)')+scale_x_continuous(breaks=1:10)+theme_bw()


  #BPS - continuous
  lmm<-lmer(scale(pd_baseline)~EventData*t1_diagnosis*sequence_position_z+
              (1|subjects)+(1|wave),data=df_trial[df_trial$sequence_position<10,])

  #model fit
  anova(lmm)
  r2_nakagawa(lmm)

        ### supplementary analysis
        lmm<-lmer(scale(pd_baseline)~t1_diagnosis*sequence_position_z+
                    (1|subjects)+(1|wave),data=df_trial[df_trial$EventData==201 & df_trial$sequence_position<10,])

        #model fit
        anova(lmm)


        #BIC Bayes Factor
        lmm_ML<-lmer(scale(pd_baseline)~t1_diagnosis*sequence_position_z+
                       (1|subjects)+(1|wave),data=df_trial[df_trial$EventData==201 & df_trial$sequence_position<10,],REML=F)

        null_lmm_ML <- lmer(scale(pd_baseline)~sequence_position_z+
                              (1|subjects)+(1|wave),data=df_trial[df_trial$EventData==201 & df_trial$sequence_position<10,],REML=F)

        BF_BIC <- exp((BIC(null_lmm_ML) - BIC(lmm_ML))/2)
        BF_BIC

  #BPS categorical
  lmm<-lmer(scale(pd_baseline)~EventData*t1_diagnosis*as.factor(sequence_position)+
              (1|subjects)+(1|wave),data=df_trial[df_trial$sequence_position<4,])

  anova(lmm)
  contrast(emmeans(lmm,~as.factor(sequence_position)),'pairwise')
  ###-> 1-3 effect
  ###inclusion of covariates leads to boundary singular

  lmm<-lmer(scale(pd_baseline)~t1_diagnosis*as.factor(sequence_position)+
              (1|subjects)+(1|wave),data=df_trial[df_trial$EventData==201 & df_trial$sequence_position<4,])

```

```{r BPS habituation between groups - Bayesian}


df_bps_bayesian_habituation<-df_trial[df_trial$EventData==201 & df_trial$sequence_position<10,]

# A. translate data - make greta arrays
y <- as_data(scale(df_bps_bayesian_habituation$pd_baseline))
design <- as.matrix(cbind(ifelse(df_bps_bayesian_habituation$t1_diagnosis=='ASD',T,F),df_bps_bayesian_habituation$sequence_position))
subject_id <- as.integer(factor(df_bps_bayesian_habituation$subjects)) #random intercept (in LMM)

#define priors
int <- normal(0, 1)
design_coef<- normal(0, 1, dim=ncol(design))
sd <- cauchy(0, 3, truncation = c(0, Inf))
#sd <- student(3, 0, 1, truncation = c(0, Inf))
a_subject <- normal(0, 1, dim = max(subject_id))

#OPERATIONS - MODEL
mean <- int + design %*% design_coef + a_subject[subject_id]

# likelihood - distribution over data
distribution(y) <- normal(mean, sd)

# defining the model
m <- model(design_coef)

# sampling
start <-Sys.time()
draws <- mcmc(m, n_samples = number_of_iterations, warmup = number_of_warmups,) ###--> test
Sys.time() - start

#stability of estimates
mcmc_trace(draws) #see whether chains converge and are stationary
mcmc_dens(draws) # + stable estimates

#analyse
summary(draws)
plot(draws)

#posterior predictive checking
coda::gelman.diag(draws) #Rhat <= 1.01 is cutoff for reliable estimator
coda::effectiveSize(draws) #ESS

#save model
draws_BPS_supp<-draws
save(draws_BPS_supp,file=paste0(project_path,'/data/Bayesian_model_BPS_supp.Rdata'))


```

## stimulus-evoked pupillary response

```{r SEPR task progression between groups LMM}

#MAIN MODEL - pupillary response by group - random intercept
lmm_REML<-lmer(scale(rpd_auc)~EventData*t1_diagnosis*EventCounter+
            (1|subjects)+(1|wave),data=df_trial)
            #--> group effect (interaction) is robust in reduced and full model

#fixed effect significances
anova(lmm_REML)

#Bayes factor - group x task progression
lmm_ML<-lmer(scale(rpd_auc)~EventData*t1_diagnosis*EventCounter+
                (1|subjects)+(1|wave),data=df_trial,REML=F)

null_lmm_ML <- lmer(scale(rpd_auc)~EventData+EventCounter+
                 EventData:EventCounter+EventData:t1_diagnosis:EventCounter+
                (1|subjects)+(1|wave),data=df_trial,REML=F)

  BF_BIC <- exp((BIC(null_lmm_ML) - BIC(lmm_ML))/2)  # BICs to Bayes factor
  BF_BIC


#full model
lmm_full<-lmer(scale(rpd_auc)~EventData*t1_diagnosis*EventCounter+
               scale(ageyrs)+scale(t1_piq)+sex+
               scale(center_dev)+as.factor(sampling_rate)+scale(missing_data_trial)+
              (1|subjects)+(1|wave),data=df_trial)
              #--> group effect (interaction) is robust in reduced and full model

anova(lmm_full)

confint(contrast(emmeans(lmm_full,~EventData|t1_diagnosis),'revpairwise'))

#coefficient of determination
r2_nakagawa(lmm_full)


hist(scale(df_trial$rpd_auc))

confint(contrast(emtrends(lmm_REML,~t1_diagnosis|EventData,var='EventCounter'),'pairwise'))
      plot(emtrends(lmm_REML,~t1_diagnosis|EventData,var='EventCounter'))
      ### --> attenuated habituation in ASD for pitch oddballs (only contrast significant in pairwise comparison)
      ##--> for rpd_auc higher pitch response in controls, higher oddball length response in ASD

```

```{r SEPR_Bayesian_three_way_interaction}

# A. translate data - make greta arrays
y <- as_data(scale(df_trial$rpd_auc))
trials <- as_data(scale(df_trial$EventCounter))
subject_id <- as.integer(factor(df_trial$subjects)) #random intercept (in LMM)
events <- as_data(model.matrix(~ EventData - 1, df_trial)) #alternative to dummy coding?
interaction_variable<-with(df_trial,interaction(t1_diagnosis,EventData))
group_by_events <- as_data(model.matrix(~interaction_variable-1, df_trial)) #alternative to dummy coding - remove intercept (-1)
#table(group_by_events[,1],group_by_events[,9])

with(df_trial,interaction(t1_diagnosis,EventData))

#define priors
event_coefs<- normal(0, 1, dim=ncol(events))
group_event_coefs <- normal(0,1, dim=ncol(group_by_events))

sd <- cauchy(0, 3, truncation = c(0, Inf))
a_subject <- normal(0, 1, dim = max(subject_id))

#OPERATIONS - MODEL
mean <- trials * group_by_events %*% group_event_coefs + a_subject[subject_id]

# likelihood - distribution over data
distribution(y) <- normal(mean, sd)

# defining the model
#m <- model(int, coef_201, coef_202, coef_203, coef_204, sd)
m <- model(group_event_coefs)

# sampling
start <-Sys.time()
draws <- mcmc(m, n_samples = number_of_iterations, warmup = number_of_warmups) ###--> test
Sys.time() - start


#estimator convergence
mcmc_trace(draws) #see whether chains converge and are stationary
mcmc_dens(draws) # + stable estimates

##results
mcmc_areas(draws, prob= .66, prob_outer = .95)+scale_y_discrete(labels=c('ASD-standard','TD-standard ','ASD-pitch','TD-pitch','ASD-length ','TD-length','ASD-pitch+length','TD-pitch+length'))+coord_flip()+theme_bw()

#analyse
summary(draws)


#posterior predictive checking
coda::gelman.diag(draws) #Rhat <= 1.01 is cutoff for reliable estimator
coda::effectiveSize(draws) #ESS

summary(draws_SEPR_threeway)

#save model
draws_SEPR_threeway<-draws
save(draws_SEPR_threeway,file=paste0(project_path,'/data/Bayesian_model_SEPR_threewayinteraction.Rdata'))


```

```{r SEPR_habituation_LMM}

  #SEPR
  lmm<-lmer(scale(rpd_auc)~EventData*t1_diagnosis*sequence_position_z+
              (1|subjects)+(1|wave),data=df_trial[df_trial$sequence_position<10,])

  anova(lmm)


  lmm<-lmer(scale(rpd_auc)~EventData*t1_diagnosis*as.factor(sequence_position)+
              (1|subjects)+(1|wave),data=df_trial[df_trial$sequence_position<4,])


      #BIC Bayes Factor
      lmm_ML<-lmer(scale(rpd_auc)~EventData*t1_diagnosis*as.factor(sequence_position)+
                     (1|subjects)+(1|wave),data=df_trial[df_trial$sequence_position<4,],REML=F)

      null_lmm_ML <- lmer(scale(rpd_auc)~1+
                            (1|subjects)+(1|wave),data=df_trial[df_trial$sequence_position<4,],REML=F)

      BF_BIC <- exp((BIC(null_lmm_ML) - BIC(lmm_ML))/2)
      BF_BIC

      BIC(null_lmm_ML)
      BIC(lmm_ML)


  lmm_full<-lmer(scale(rpd_auc)~EventData*t1_diagnosis*sequence_position_z+
                scale(ageyrs)+scale(t1_piq)+sex+
                 scale(center_dev)+as.factor(sampling_rate)+scale(missing_data_trial)+
              (1|subjects)+(1|wave),data=df_trial[df_trial$sequence_position<10,])
    
  anova(lmm_full)
  ###--> if an oddballs follows an oddball - higehr response in ASD
  ###--> if oddball follows a standard - higher response in TD

  contrast(emmeans(lmm,~t1_diagnosis|EventData+as.factor(sequence_position)),'pairwise')
  confint(contrast(emmeans(lmm,~t1_diagnosis|EventData+as.factor(sequence_position)),'revpairwise'))

```

```{r SEPR_habituation_Bayesian}

df_sepr_bayesian_habituation<-df_trial[df_trial$sequence_position<4,]

# A. translate data - make greta arrays
y <- as_data(scale(df_sepr_bayesian_habituation$rpd_auc))
interaction_variable<-with(df_sepr_bayesian_habituation,interaction(t1_diagnosis,sequence_position))
group_by_events <- as_data(model.matrix(~interaction_variable-1, df_sepr_bayesian_habituation)) #alternative to dummy coding - remove intercept (-1)
subject_id <- as.integer(factor(df_sepr_bayesian_habituation$subjects)) #random intercept (in LMM)

#define priors
int <- normal(0, 1)
design_coef<- normal(0, 1, dim=ncol(group_by_events))
sd <- cauchy(0, 3, truncation = c(0, Inf))
a_subject <- normal(0, 1, dim = max(subject_id))

#OPERATIONS - MODEL
mean <- int + group_by_events %*% design_coef + a_subject[subject_id]

# likelihood - distribution over data
distribution(y) <- normal(mean, sd)

# defining the model
m <- model(design_coef)

# sampling
start <-Sys.time()
draws <- mcmc(m, n_samples = number_of_iterations, warmup = number_of_warmups,) ###--> test
Sys.time() - start

#stability of estimates
mcmc_trace(draws) #see whether chains converge and are stationary
mcmc_dens(draws) # + stable estimates

#analyse
table(interaction_variable) #names of coefficients
summary(draws)
plot(draws)

#posterior predictive checking
coda::gelman.diag(draws) #Rhat <= 1.01 is cutoff for reliable estimator
coda::effectiveSize(draws) #ESS

#save model
draws_SEPR_habituation<-draws
save(draws_SEPR_habituation,file=paste0(project_path,'/data/Bayesian_model_SEPR_habituation.Rdata'))

```

## mismatch negativity between groups

```{r MMN - LLM}

#MAIN MODEL - MN by group - random intercept
lmm_REML<-lmer(scale(mmn)~EventData*t1_diagnosis*EventCounter+
            (1|id),data=df_trial)

#fixed effect significances
anova(lmm_REML)

#Bayes factor - group x task progression
lmm_ML<-lmer(scale(mmn)~EventData*t1_diagnosis*EventCounter+
                (1|id),data=df_trial,REML=F)

null_lmm_ML <- lmer(scale(mmn)~EventData+EventCounter+
                 EventData:EventCounter+EventData:t1_diagnosis:EventCounter+
                (1|id),data=df_trial,REML=F)

  BF_BIC <- exp((BIC(null_lmm_ML) - BIC(lmm_ML))/2)  # BICs to Bayes factor
  BF_BIC


#full model
lmm_full<-lmer(scale(mmn)~EventData*t1_diagnosis*EventCounter+
               scale(ageyrs)+scale(t1_piq)+sex+
               scale(center_dev)+as.factor(sampling_rate)+scale(missing_data_trial)+
              (1|id),data=df_trial)
              #--> group effect (interaction) is robust in reduced and full model

anova(lmm_full)

#coefficient of determination
r2_nakagawa(lmm_full)


confint(contrast(emtrends(lmm_REML,~t1_diagnosis|EventData,var='EventCounter'),'pairwise'))
      plot(emtrends(lmm_REML,~t1_diagnosis|EventData,var='EventCounter'))



```


## computational modelling - PCDM - neural gain

```{r PCDM_neural_gain_analysis}


#data quality for neural gain
with(df_timepoint,table(Rsq_pcdm>=0.2,t1_diagnosis))
chisq.test(with(df_timepoint,table(Rsq_pcdm>=0.2,t1_diagnosis)))

#higher gain for standards in ASD
lm_gain<-lm(scale(gain_pcdm)~t1_diagnosis,df_timepoint[df_timepoint$Rsq_pcdm>0.2,])
summary(lm_gain) #higher gain in ASD for standards
anova(lm_gain) #higher gain in ASD for standards

t.test(scale(gain_pcdm)~t1_diagnosis,df_timepoint[df_timepoint$Rsq_pcdm>0.2,])
cohens_d(x=scale(gain_pcdm)~t1_diagnosis,data=df_timepoint[df_timepoint$Rsq_pcdm>0.2,])
#--> d=0.4 in ASD

#visualize
ggplot(df_timepoint[df_timepoint$Rsq_pcdm>0.2, ],aes(x=scale(gain_pcdm),fill=t1_diagnosis))+geom_histogram(aes(y = after_stat(density)),position='dodge',bins=20)+theme_bw()

###scaling with demographic data
summary(lm(scale(gain_pcdm)~ageyrs,df_timepoint[df_timepoint$Rsq_pcdm>0.2,]))
summary(lm(scale(gain_pcdm)~t1_piq,df_timepoint[df_timepoint$Rsq_pcdm>0.2,]))
summary(lm(scale(gain_pcdm)~sex,df_timepoint[df_timepoint$Rsq_pcdm>0.2,]))

# summary(lm(scale(gain_pcdm)~rpd_auc.201,df_timepoint[df_timepoint$Rsq_pcdm>0.2,]))
# summary(lm(scale(gain_pcdm)~rpd_auc.202,df_timepoint[df_timepoint$Rsq_pcdm>0.2,]))
# summary(lm(scale(gain_pcdm)~rpd_auc.203,df_timepoint[df_timepoint$Rsq_pcdm>0.2,]))
# summary(lm(scale(gain_pcdm)~rpd_auc.204,df_timepoint[df_timepoint$Rsq_pcdm>0.2,]))
# summary(lm(scale(gain_pcdm)~pd_baseline,df_timepoint[df_timepoint$Rsq_pcdm>0.2,]))


```

## figure group differences

```{r figure_BPS_SEP_between_groups}
#main models
BPS_progression<-lmer(scale(pd_baseline)~EventData*t1_diagnosis*EventCounter+
              (1|subjects)+(1|wave),data=df_trial)

BPS_habituation<-lmer(scale(pd_baseline)~t1_diagnosis*sequence_position+
                    (1|subjects)+(1|wave),data=df_trial[df_trial$EventData==201 & df_trial$sequence_position<=10,])

SEPR_progression<-lmer(scale(rpd_auc)~EventData*t1_diagnosis*EventCounter+
              (1|subjects)+(1|wave),data=df_trial)

MMN_progression<-lmer(scale(mmn)~EventData*t1_diagnosis*EventCounter+
              (1|id),data=df_trial)
  

#plot interaction
model_plot_data_BPS1<-as.data.frame(emmeans(BPS_progression,~t1_diagnosis+EventCounter,
                                       at=list(EventCounter = seq(1,1400,140))))

g1<-ggplot(model_plot_data_BPS1,aes(x=EventCounter,y=emmean,group=t1_diagnosis,color=t1_diagnosis))+
  geom_crossbar(aes(ymin=emmean-1*SE,ymax=emmean+1*SE,fill=t1_diagnosis),alpha=0.8,position='dodge')+
  geom_errorbar(aes(ymin=asymp.LCL,ymax=asymp.UCL),position='dodge')+
  scale_color_manual(name = "groups", labels = c("autistic", "neurotypical"),values = brewer.pal(3, "Dark2")[1:2])+
  scale_fill_manual(name = "groups", labels = c("autistic", "neurotypical"),values = brewer.pal(3, "Dark2")[1:2])+
  labs(x='task progression (trial)')+
  theme(axis.title.y=element_blank(),legend.position = 'none')

model_plot_data_BPS2<-as.data.frame(emmeans(BPS_habituation,~t1_diagnosis+sequence_position,
                                       at=list(sequence_position = seq(1,10))))

g2<-ggplot(model_plot_data_BPS2,aes(x=sequence_position,y=emmean,group=t1_diagnosis,color=t1_diagnosis))+
  geom_crossbar(aes(ymin=emmean-1*SE,ymax=emmean+1*SE,fill=t1_diagnosis),alpha=0.8,position='dodge')+
  geom_errorbar(aes(ymin=asymp.LCL,ymax=asymp.UCL),position='dodge')+
  scale_color_manual(name = "groups", labels = c("autistic", "neurotypical"),values = brewer.pal(3, "Dark2")[1:2])+
  scale_fill_manual(name = "groups", labels = c("autistic", "neurotypical"),values = brewer.pal(3, "Dark2")[1:2])+
  scale_x_continuous(breaks=seq(0,10,1))+
  labs(x='sequence position')+
  theme(axis.title.y=element_blank(),legend.position = 'none')


model_plot_data_SEPR<-as.data.frame(emmeans(SEPR_progression,~t1_diagnosis+EventData+EventCounter,at=list(EventCounter = seq(1,1400,140))))
    
    labels <- c("201" = "standard", "202" = "pitch oddball", "203" = "length oddball", "204" = "pitch & length oddball")
g3<-ggplot(model_plot_data_SEPR,aes(x=EventCounter,y=emmean,
                           group=interaction(EventData,t1_diagnosis),color=t1_diagnosis))+
  geom_crossbar(aes(ymin=emmean-1*SE,ymax=emmean+1*SE,fill=t1_diagnosis),alpha=0.8,position='dodge')+
  geom_errorbar(aes(ymin=asymp.LCL,ymax=asymp.UCL),position='dodge')+
  scale_color_manual(name = "groups", labels = c("autistic", "neurotypical"),values = brewer.pal(3, "Dark2")[1:2])+
  scale_fill_manual(name = "groups", labels = c("autistic", "neurotypical"),values = brewer.pal(3, "Dark2")[1:2])+
  facet_wrap(~EventData,labeller=labeller(EventData = labels))+
  labs(x='task progression (trial)',y='stimulus-evoked pupillary response - SEPR (z)')


model_plot_data_MMN<-as.data.frame(emmeans(MMN_progression,~t1_diagnosis+EventData+EventCounter,at=list(EventCounter = seq(1,1400,140))))
    
    labels <- c("201" = "standard", "202" = "pitch oddball", "203" = "length oddball", "204" = "pitch & length oddball")
g4<-ggplot(model_plot_data_MMN,aes(x=EventCounter,y=emmean,
                           group=interaction(EventData,t1_diagnosis),color=t1_diagnosis))+
  geom_crossbar(aes(ymin=emmean-1*SE,ymax=emmean+1*SE,fill=t1_diagnosis),alpha=0.8,position='dodge')+
  geom_errorbar(aes(ymin=asymp.LCL,ymax=asymp.UCL),position='dodge')+
  scale_color_manual(name = "groups", labels = c("autistic", "neurotypical"),values = brewer.pal(3, "Dark2")[1:2])+
  scale_fill_manual(name = "groups", labels = c("autistic", "neurotypical"),values = brewer.pal(3, "Dark2")[1:2])+
  facet_wrap(~EventData,labeller=labeller(EventData = labels))+
  labs(x='task progression (trial)',y='mismatch negativity - MMN (z)')

  
lay <- rbind(c(1,1,3,3,3,5),
             c(1,1,3,3,3,5),
             c(1,1,3,3,3,5),
             c(2,2,4,4,4,5),
             c(2,2,4,4,4,5),
             c(2,2,4,4,4,5))


g_legend<-function(x){
  tmp <- ggplot_gtable(ggplot_build(x))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)}

mylegend_group<-g_legend(g4)


#plot in markdown
grid.arrange(g1,g2,
             g3+theme(legend.position = 'none'),
             g4+theme(legend.position = 'none'),
             mylegend_group, left='baseline pupil size (z)', layout_matrix=lay)


#save to file
tiff(file=paste0(project_path,"/output/figures/group_differences.tiff"), # create a file in tiff format in current working directory
  width=9, height=7, units="in", res=300, compression='lzw') #define size and resolution of the resulting figure
      
grid.arrange(g1,g2,
             g3+theme(legend.position = 'none'),
             g4+theme(legend.position = 'none'),
             mylegend_group, left='baseline pupil size (z)', layout_matrix=lay)

dev.off() #close operation and save file




```

# supplementary analyses

## linearity of effect of trial number

```{r trial_number_modelcomparison BPS}

###polynomial fit of trial counter
  linear_fit<-lmer(scale(pd_baseline)~EventData*t1_diagnosis*scale(EventCounter)+
          (1|subjects)+(1|wave),data=df_trial,REML=F)

  quadratic_fit<-lmer(scale(pd_baseline)~EventData*t1_diagnosis*poly(scale(EventCounter),2)+
              (1|subjects)+(1|wave),data=df_trial,REML=F)

  cubic_fit<-lmer(scale(pd_baseline)~EventData*t1_diagnosis*poly(scale(EventCounter),3)+
               (1|subjects)+(1|wave),data=df_trial,REML=F)
  
  quartic_fit<-lmer(scale(pd_baseline)~EventData*t1_diagnosis*poly(scale(EventCounter),4)+
               (1|subjects)+(1|wave),data=df_trial,REML=F)

  quintic_fit<-lmer(scale(pd_baseline)~EventData*t1_diagnosis*poly(scale(EventCounter),5)+
               (1|subjects)+(1|wave),data=df_trial,REML=F)

  sextic_fit<-lmer(scale(pd_baseline)~EventData*t1_diagnosis*poly(scale(EventCounter),6)+
               (1|subjects)+(1|wave),data=df_trial,REML=F)

  septic_fit<-lmer(scale(pd_baseline)~EventData*t1_diagnosis*poly(scale(EventCounter),7)+
               (1|subjects)+(1|wave),data=df_trial,REML=F)

  anova(linear_fit,quadratic_fit,cubic_fit,quartic_fit,quintic_fit,sextic_fit,septic_fit)
  
  table_model_compare<-anova(linear_fit,quadratic_fit,cubic_fit)
  
  table_model_compare<-cbind(c('linear fit','quadratic fit','cubic fit','qaurtic fit','quintic fit'),table_model_compare)
  
  table_formatted<-table_model_compare %>%
  kbl(caption = "Model comparison on the linearity of trial number on stimulus-evoked pupillary response",
      col.names = c('','number of parameters','AIC','BIC','log likelihood','deviance','Chi-squared','df','p-value'),
      row.names = F) %>%
  kable_classic(full_width = F, html_font = "Cambria")

table_formatted

save_kable(table_formatted, file=paste0(project_path,'/output/supplements/table_modelcomparison_linearity_trialnumber_onBPS.html'))
  
  
```


## intraclass correaltion of the dependent variables

```{r ICC_of_dependent_variables}

#select only individuals that have both waves
subjects_with_both_waves<-df_dem$subjects[df_dem$timepoints=='wave1+2']
df_trial_wave12<-df_trial[df_trial$subjects %in% subjects_with_both_waves,]

#BPS
baseline_pd_wave1<-with(df_trial_wave12[df_trial_wave12$wave=='wave1',],aggregate(pd_baseline,by=list(subjects),FUN=mean,na.rm=T))
baseline_pd_wave2<-with(df_trial_wave12[df_trial_wave12$wave=='wave2',],aggregate(pd_baseline,by=list(subjects),FUN=mean,na.rm=T))
names(baseline_pd_wave1)<-c('subjects','wave1')
names(baseline_pd_wave2)<-c('subjects','wave2')

baseline_pd_waves<-merge(baseline_pd_wave1,baseline_pd_wave2,by='subjects')

cor.test(baseline_pd_waves$wave1,baseline_pd_waves$wave2)

psych::ICC(baseline_pd_waves[,-1])
###--> ICC: 0.88 [0.81, 0.93]


#SEPR
rpd204_wave1<-with(df_trial_wave12[df_trial_wave12$EventData=='204' & df_trial_wave12$wave=='wave1',],aggregate(rpd_auc.204,by=list(subjects),FUN=mean,na.rm=T))
rpd204_wave2<-with(df_trial_wave12[df_trial_wave12$EventData=='204' & df_trial_wave12$wave=='wave2',],aggregate(rpd_auc.204,by=list(subjects),FUN=mean,na.rm=T))

names(rpd204_wave1)<-c('subjects','wave1')
names(rpd204_wave2)<-c('subjects','wave2')

rpd_waves<-merge(rpd204_wave1,rpd204_wave2,by='subjects')

cor.test(rpd_waves$wave1,rpd_waves$wave2)
##--> r =.23

psych::ICC(rpd_waves[,-1])
###--> ICC: 0.37 [-0.01, 0.60]


names(df_timepoint)

#NG
gain_wave1<-with(df_timepoint[df_timepoint$wave=='wave1',],aggregate(gain_pcdm,by=list(subjects),FUN=mean,na.rm=T))
gain_wave2<-with(df_timepoint[df_timepoint$wave=='wave2',],aggregate(gain_pcdm,by=list(subjects),FUN=mean,na.rm=T))

names(gain_wave1)<-c('subjects','wave1')
names(gain_wave2)<-c('subjects','wave2')

gain_waves<-merge(gain_wave1,gain_wave2,by='subjects')

cor.test(gain_waves$wave1,gain_waves$wave2)
##--> r =.23

psych::ICC(gain_waves[,-1])
###--> ICC: 0.37 [0.02, 0.59]

```




